
# Asteroids Multiplayer Game

Это многопользовательская (2 игрока) версия классической игры Asteroids с использованием Python и Pygame. Имеется сервер и клиент, взаимодействующие по TCP.

Оба игрока управляют космическими кораблями, стреляют по астероидам и друг другу, получают очки за уничтожение противника или астероидов. Игра заканчивается по истечении заданного времени или когда кто‑то набрал достаточно очков (в данном примере — по времени, 300 секунд).

## Состав проекта

- **server.py** — Запускает сервер.
  - Поднимает TCP-сокет.
  - Хранит два слота для двух игроков (player_id = 0, 1).
  - Запускает игровой цикл (каждые ~1/60 секунды вызывает GameLogic.update()).
  - Рассылает текущее состояние (корабли, астероиды, лазеры, очки, оставшееся время) клиентам.
  - При истечении времени рассылает game_over с информацией о победителе (или ничьей).
  - Если один из игроков отключается, слот сохраняется и ждет повторного подключения того же player_id.

- **client.py** — Запускает клиента.
  - Подключается к серверу и отправляет {action:"hello", payload:{player_id:...}}.
  - После принятия сервером, шлет команды update_position и shoot.
  - Получает update_state и game_over, локально отрисовывает корабли, астероиды, лазеры, счет и таймер.

- **ship.py** — Класс Ship: хранит логику для одного корабля (HP, выстрелы, респаун, движение).

- **asteroid.py** — AsteroidManager: хранит и обновляет астероиды.

- **laser.py** — LaserManager: хранит и обновляет лазеры.

- **gamelogic.py** — GameLogic: отвечает за столкновения, очки, время, завершение игры.

- **utils.py** — Константы (размер экрана, цвета и т. д.), глобальные параметры (FPS, TIME).

## Логика протокола (между клиентом и сервером)

- Первое сообщение от клиента — hello с player_id (0 или 1).

```json
{
  "action": "hello",
  "payload": { "player_id": 0 }
}
```

- Сервер проверяет, свободен ли слот, и либо принимает, либо разрывает соединение.
- Далее клиент посылает:

  - **update_position:** содержит новую позицию и угол корабля.

```json
{
  "action":"update_position",
  "payload": {
    "pos":[123, 456],
    "angle": 270
  }
}
```

  - **shoot:** команда выстрела.

```json
{
  "action":"shoot",
  "payload": {}
}
```

- Сервер отвечает сообщениями:
  - **update_state:**

```json
{
  "event": "update_state",
  "payload": {
    "ships": [...],
    "asteroids": [...],
    "lasers": [...],
    "score": [0, 0],
    "time_left": 299
  }
}
```

которое приходит каждый кадр (или с некоторой периодичностью).
  - **game_over:**

```json
{
  "event": "game_over",
  "payload": {
    "scores":[5,3],
    "winner": 1
  }
}
```

(winner=1 значит выиграл ship0 или "Player1". winner=0 значит ничья).

Каждое сообщение заканчивается символом `\n`, а обе стороны построчно парсят входящие данные, вызывая `json.loads(...)` на каждую строку.

## Принцип работы

1. Сервер запускается (`python server.py`), слушает порт 12345.
2. Два клиента запускаются (`python client.py 0` и `python client.py 1`) и отсылают серверу `player_id=0` и `player_id=1` соответственно.
3. Сервер назначает каждому клиенту слот, создает им корабли `Ship`, начинает игровой цикл.
4. Каждые ~16 мс (при 60 FPS) сервер:
   - Обновляет астероиды, лазеры, проверяет столкновения (через `GameLogic`).
   - Рассылает каждому подключенному клиенту текущее состояние (`update_state`).
5. Клиенты принимают это состояние, рисуют на экране текущее расположение объектов, и параллельно отсылают свои действия (`shoot` / `update_position`).
6. Когда истекает время (или по иной логике), сервер шлет `game_over` с результатами (кто набрал больше очков).
7. Если клиент отключается, сервер сохраняет его слот и ждет этого же игрока (с тем же `player_id`) для продолжения.
